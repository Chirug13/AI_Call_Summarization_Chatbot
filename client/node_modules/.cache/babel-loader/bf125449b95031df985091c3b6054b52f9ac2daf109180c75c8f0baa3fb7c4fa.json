{"ast":null,"code":"export async function uploadAudio(file) {\n  const formData = new FormData();\n  formData.append('file', file);\n  try {\n    const res = await fetch('http://localhost:8000/transcribe', {\n      method: 'POST',\n      body: formData\n    });\n    return await res.json();\n  } catch (err) {\n    console.error('Upload Error:', err);\n    return {\n      transcript: ''\n    };\n  }\n}\nexport async function startMicRecordingWithSilence(callback) {\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true\n  });\n  const mediaRecorder = new MediaRecorder(stream);\n  const audioChunks = [];\n  let silenceTimer;\n  let audioContext = new AudioContext();\n  let source = audioContext.createMediaStreamSource(stream);\n  let analyser = audioContext.createAnalyser();\n  source.connect(analyser);\n  let data = new Uint8Array(analyser.fftSize);\n  const detectSilence = () => {\n    analyser.getByteTimeDomainData(data);\n    let max = Math.max(...data);\n    let min = Math.min(...data);\n    if (max - min < 5) {\n      if (!silenceTimer) {\n        silenceTimer = setTimeout(() => {\n          mediaRecorder.stop();\n        }, 3000); // Stop after 3s silence\n      }\n    } else {\n      if (silenceTimer) {\n        clearTimeout(silenceTimer);\n        silenceTimer = null;\n      }\n    }\n    if (mediaRecorder.state === 'recording') {\n      requestAnimationFrame(detectSilence);\n    }\n  };\n  return new Promise(resolve => {\n    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);\n    mediaRecorder.onstop = async () => {\n      const audioBlob = new Blob(audioChunks, {\n        type: 'audio/wav'\n      });\n      const audioFile = new File([audioBlob], 'recorded.wav', {\n        type: 'audio/wav'\n      });\n      const result = await uploadAudio(audioFile);\n      callback(result.transcript); // return text to caller\n      resolve();\n    };\n    mediaRecorder.start();\n    detectSilence();\n  });\n}","map":{"version":3,"names":["uploadAudio","file","formData","FormData","append","res","fetch","method","body","json","err","console","error","transcript","startMicRecordingWithSilence","callback","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","audioChunks","silenceTimer","audioContext","AudioContext","source","createMediaStreamSource","analyser","createAnalyser","connect","data","Uint8Array","fftSize","detectSilence","getByteTimeDomainData","max","Math","min","setTimeout","stop","clearTimeout","state","requestAnimationFrame","Promise","resolve","ondataavailable","e","push","onstop","audioBlob","Blob","type","audioFile","File","result","start"],"sources":["D:/Redhats/AI_Call_Summarization_V2/client/src/audioUtils.js"],"sourcesContent":["export async function uploadAudio(file) {\r\n  const formData = new FormData();\r\n  formData.append('file', file);\r\n  try {\r\n    const res = await fetch('http://localhost:8000/transcribe', {\r\n      method: 'POST',\r\n      body: formData,\r\n    });\r\n    return await res.json();\r\n  } catch (err) {\r\n    console.error('Upload Error:', err);\r\n    return { transcript: '' };\r\n  }\r\n}\r\n\r\nexport async function startMicRecordingWithSilence(callback) {\r\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n  const mediaRecorder = new MediaRecorder(stream);\r\n  const audioChunks = [];\r\n  let silenceTimer;\r\n  let audioContext = new AudioContext();\r\n  let source = audioContext.createMediaStreamSource(stream);\r\n  let analyser = audioContext.createAnalyser();\r\n  source.connect(analyser);\r\n  let data = new Uint8Array(analyser.fftSize);\r\n\r\n  const detectSilence = () => {\r\n    analyser.getByteTimeDomainData(data);\r\n    let max = Math.max(...data);\r\n    let min = Math.min(...data);\r\n    if (max - min < 5) {\r\n      if (!silenceTimer) {\r\n        silenceTimer = setTimeout(() => {\r\n          mediaRecorder.stop();\r\n        }, 3000); // Stop after 3s silence\r\n      }\r\n    } else {\r\n      if (silenceTimer) {\r\n        clearTimeout(silenceTimer);\r\n        silenceTimer = null;\r\n      }\r\n    }\r\n    if (mediaRecorder.state === 'recording') {\r\n      requestAnimationFrame(detectSilence);\r\n    }\r\n  };\r\n\r\n  return new Promise((resolve) => {\r\n    mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);\r\n    mediaRecorder.onstop = async () => {\r\n      const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\r\n      const audioFile = new File([audioBlob], 'recorded.wav', { type: 'audio/wav' });\r\n      const result = await uploadAudio(audioFile);\r\n      callback(result.transcript); // return text to caller\r\n      resolve();\r\n    };\r\n\r\n    mediaRecorder.start();\r\n    detectSilence();\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}